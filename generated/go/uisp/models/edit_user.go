// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// EditUser edit user
//
// swagger:model EditUser
type EditUser struct {

	// alerts
	// Required: true
	Alerts *bool `json:"alerts"`

	// current password
	// Max Length: 64
	// Min Length: 4
	CurrentPassword string `json:"currentPassword,omitempty"`

	// email
	Email string `json:"email,omitempty"`

	// first name
	FirstName string `json:"firstName,omitempty"`

	// force change password
	// Required: true
	ForceChangePassword *bool `json:"forceChangePassword"`

	// home screen
	HomeScreen string `json:"homeScreen,omitempty"`

	// Whether session should be cleared when browser window is closed.
	// Example: true
	KeepMeSignedIn bool `json:"keepMeSignedIn,omitempty"`

	// last log item Id
	LastLogItemID string `json:"lastLogItemId,omitempty"`

	// last name
	LastName string `json:"lastName,omitempty"`

	// new password
	// Max Length: 64
	// Min Length: 4
	NewPassword string `json:"newPassword,omitempty"`

	// preferences
	Preferences Preferences `json:"preferences,omitempty"`

	// presentation mode
	PresentationMode bool `json:"presentationMode,omitempty"`

	// Ignored, user cannot change his own role.
	Role string `json:"role,omitempty"`

	// session timeout
	// Minimum: 1
	SessionTimeout int64 `json:"sessionTimeout,omitempty"`

	// table config
	TableConfig TableConfig `json:"tableConfig,omitempty"`

	// ucrm Id
	// Example: 123
	UcrmID string `json:"ucrmId,omitempty"`

	// ucrm role
	UcrmRole string `json:"ucrmRole,omitempty"`

	// username
	// Required: true
	// Max Length: 320
	// Min Length: 1
	// Pattern: ^[a-zA-Z0-9_]*$
	Username *string `json:"username"`
}

// Validate validates this edit user
func (m *EditUser) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlerts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForceChangePassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionTimeout(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsername(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EditUser) validateAlerts(formats strfmt.Registry) error {

	if err := validate.Required("alerts", "body", m.Alerts); err != nil {
		return err
	}

	return nil
}

func (m *EditUser) validateCurrentPassword(formats strfmt.Registry) error {
	if swag.IsZero(m.CurrentPassword) { // not required
		return nil
	}

	if err := validate.MinLength("currentPassword", "body", m.CurrentPassword, 4); err != nil {
		return err
	}

	if err := validate.MaxLength("currentPassword", "body", m.CurrentPassword, 64); err != nil {
		return err
	}

	return nil
}

func (m *EditUser) validateForceChangePassword(formats strfmt.Registry) error {

	if err := validate.Required("forceChangePassword", "body", m.ForceChangePassword); err != nil {
		return err
	}

	return nil
}

func (m *EditUser) validateNewPassword(formats strfmt.Registry) error {
	if swag.IsZero(m.NewPassword) { // not required
		return nil
	}

	if err := validate.MinLength("newPassword", "body", m.NewPassword, 4); err != nil {
		return err
	}

	if err := validate.MaxLength("newPassword", "body", m.NewPassword, 64); err != nil {
		return err
	}

	return nil
}

func (m *EditUser) validateSessionTimeout(formats strfmt.Registry) error {
	if swag.IsZero(m.SessionTimeout) { // not required
		return nil
	}

	if err := validate.MinimumInt("sessionTimeout", "body", m.SessionTimeout, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *EditUser) validateUsername(formats strfmt.Registry) error {

	if err := validate.Required("username", "body", m.Username); err != nil {
		return err
	}

	if err := validate.MinLength("username", "body", *m.Username, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("username", "body", *m.Username, 320); err != nil {
		return err
	}

	if err := validate.Pattern("username", "body", *m.Username, `^[a-zA-Z0-9_]*$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this edit user based on context it is used
func (m *EditUser) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *EditUser) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EditUser) UnmarshalBinary(b []byte) error {
	var res EditUser
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
