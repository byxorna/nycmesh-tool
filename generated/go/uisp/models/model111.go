// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Model111 model 111
//
// swagger:model Model 111
type Model111 struct {

	// application Id
	// Minimum: 1
	ApplicationID int64 `json:"applicationId,omitempty"`

	// bytes
	// Required: true
	// Minimum: 0
	Bytes *int64 `json:"bytes"`

	// category Id
	// Minimum: 0
	CategoryID *int64 `json:"categoryId,omitempty"`

	// connection state
	// Required: true
	ConnectionState ConnectionState `json:"connectionState"`

	// description
	Description string `json:"description,omitempty"`

	// destination
	Destination *Destination `json:"destination,omitempty"`

	// enabled
	Enabled bool `json:"enabled,omitempty"`

	// icmp type
	// Enum: [address-mask-reply address-mask-request any communication-prohibited destination-unreachable echo-reply echo-request fragmentation-needed host-precedence-violation host-prohibited host-redirect host-unknown host-unreachable ip-header-bad network-prohibited network-redirect network-unknown network-unreachable parameter-problem port-unreachable precedence-cutoff protocol-unreachable redirect required-option-missing router-advertisement router-solicitation source-quench source-route-failed time-exceeded timestamp-reply timestamp-request TOS-host-redirect TOS-host-unreachable TOS-network-redirect TOS-network-unreachable ttl-zero-during-reassembly ttl-zero-during-transit]
	IcmpType string `json:"icmpType,omitempty"`

	// icmpv6 type
	// Enum: [address-unreachable bad-header beyond-scope communication-prohibited destination-unreachable echo-reply echo-request failed-policy neighbor-advertisement neighbor-solicitation no-route packet-too-big parameter-problem port-unreachable redirect reject-route router-advertisement router-solicitation time-exceeded ttl-zero-during-reassembly ttl-zero-during-transit unknown-header-type unknown-option]
	Icmpv6Type string `json:"icmpv6Type,omitempty"`

	// id
	// Minimum: 0
	ID *int64 `json:"id,omitempty"`

	// in interface
	InInterface *InInterface1 `json:"inInterface,omitempty"`

	// ip version
	// Required: true
	// Enum: [both v4only v6only]
	IPVersion *string `json:"ipVersion"`

	// ipsec policy
	// Enum: [match_inbound_ipsec match_inbound_nonipsec]
	IpsecPolicy string `json:"ipsecPolicy,omitempty"`

	// log
	Log bool `json:"log,omitempty"`

	// negate in interface
	NegateInInterface bool `json:"negateInInterface,omitempty"`

	// negate out interface
	NegateOutInterface bool `json:"negateOutInterface,omitempty"`

	// out interface
	OutInterface *OutInterface1 `json:"outInterface,omitempty"`

	// packets
	// Required: true
	// Minimum: 0
	Packets *int64 `json:"packets"`

	// protocol
	// Required: true
	Protocol *string `json:"protocol"`

	// reject with
	// Enum: [icmp_net_unreachable icmp_host_unreachable icmp_port_unreachable icmp_proto_unreachable icmp_net_prohibited icmp_host_prohibited icmp_admin_prohibited tcp_reset,]
	RejectWith string `json:"rejectWith,omitempty"`

	// source
	Source *Source `json:"source,omitempty"`

	// target
	// Required: true
	Target *string `json:"target"`
}

// Validate validates this model 111
func (m *Model111) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplicationID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategoryID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIcmpType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIcmpv6Type(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIpsecPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutInterface(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePackets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRejectWith(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Model111) validateApplicationID(formats strfmt.Registry) error {
	if swag.IsZero(m.ApplicationID) { // not required
		return nil
	}

	if err := validate.MinimumInt("applicationId", "body", m.ApplicationID, 1, false); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateBytes(formats strfmt.Registry) error {

	if err := validate.Required("bytes", "body", m.Bytes); err != nil {
		return err
	}

	if err := validate.MinimumInt("bytes", "body", *m.Bytes, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateCategoryID(formats strfmt.Registry) error {
	if swag.IsZero(m.CategoryID) { // not required
		return nil
	}

	if err := validate.MinimumInt("categoryId", "body", *m.CategoryID, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateConnectionState(formats strfmt.Registry) error {

	if err := validate.Required("connectionState", "body", m.ConnectionState); err != nil {
		return err
	}

	if err := m.ConnectionState.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("connectionState")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("connectionState")
		}
		return err
	}

	return nil
}

func (m *Model111) validateDestination(formats strfmt.Registry) error {
	if swag.IsZero(m.Destination) { // not required
		return nil
	}

	if m.Destination != nil {
		if err := m.Destination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

var model111TypeIcmpTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["address-mask-reply","address-mask-request","any","communication-prohibited","destination-unreachable","echo-reply","echo-request","fragmentation-needed","host-precedence-violation","host-prohibited","host-redirect","host-unknown","host-unreachable","ip-header-bad","network-prohibited","network-redirect","network-unknown","network-unreachable","parameter-problem","port-unreachable","precedence-cutoff","protocol-unreachable","redirect","required-option-missing","router-advertisement","router-solicitation","source-quench","source-route-failed","time-exceeded","timestamp-reply","timestamp-request","TOS-host-redirect","TOS-host-unreachable","TOS-network-redirect","TOS-network-unreachable","ttl-zero-during-reassembly","ttl-zero-during-transit"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model111TypeIcmpTypePropEnum = append(model111TypeIcmpTypePropEnum, v)
	}
}

const (

	// Model111IcmpTypeAddressDashMaskDashReply captures enum value "address-mask-reply"
	Model111IcmpTypeAddressDashMaskDashReply string = "address-mask-reply"

	// Model111IcmpTypeAddressDashMaskDashRequest captures enum value "address-mask-request"
	Model111IcmpTypeAddressDashMaskDashRequest string = "address-mask-request"

	// Model111IcmpTypeAny captures enum value "any"
	Model111IcmpTypeAny string = "any"

	// Model111IcmpTypeCommunicationDashProhibited captures enum value "communication-prohibited"
	Model111IcmpTypeCommunicationDashProhibited string = "communication-prohibited"

	// Model111IcmpTypeDestinationDashUnreachable captures enum value "destination-unreachable"
	Model111IcmpTypeDestinationDashUnreachable string = "destination-unreachable"

	// Model111IcmpTypeEchoDashReply captures enum value "echo-reply"
	Model111IcmpTypeEchoDashReply string = "echo-reply"

	// Model111IcmpTypeEchoDashRequest captures enum value "echo-request"
	Model111IcmpTypeEchoDashRequest string = "echo-request"

	// Model111IcmpTypeFragmentationDashNeeded captures enum value "fragmentation-needed"
	Model111IcmpTypeFragmentationDashNeeded string = "fragmentation-needed"

	// Model111IcmpTypeHostDashPrecedenceDashViolation captures enum value "host-precedence-violation"
	Model111IcmpTypeHostDashPrecedenceDashViolation string = "host-precedence-violation"

	// Model111IcmpTypeHostDashProhibited captures enum value "host-prohibited"
	Model111IcmpTypeHostDashProhibited string = "host-prohibited"

	// Model111IcmpTypeHostDashRedirect captures enum value "host-redirect"
	Model111IcmpTypeHostDashRedirect string = "host-redirect"

	// Model111IcmpTypeHostDashUnknown captures enum value "host-unknown"
	Model111IcmpTypeHostDashUnknown string = "host-unknown"

	// Model111IcmpTypeHostDashUnreachable captures enum value "host-unreachable"
	Model111IcmpTypeHostDashUnreachable string = "host-unreachable"

	// Model111IcmpTypeIPDashHeaderDashBad captures enum value "ip-header-bad"
	Model111IcmpTypeIPDashHeaderDashBad string = "ip-header-bad"

	// Model111IcmpTypeNetworkDashProhibited captures enum value "network-prohibited"
	Model111IcmpTypeNetworkDashProhibited string = "network-prohibited"

	// Model111IcmpTypeNetworkDashRedirect captures enum value "network-redirect"
	Model111IcmpTypeNetworkDashRedirect string = "network-redirect"

	// Model111IcmpTypeNetworkDashUnknown captures enum value "network-unknown"
	Model111IcmpTypeNetworkDashUnknown string = "network-unknown"

	// Model111IcmpTypeNetworkDashUnreachable captures enum value "network-unreachable"
	Model111IcmpTypeNetworkDashUnreachable string = "network-unreachable"

	// Model111IcmpTypeParameterDashProblem captures enum value "parameter-problem"
	Model111IcmpTypeParameterDashProblem string = "parameter-problem"

	// Model111IcmpTypePortDashUnreachable captures enum value "port-unreachable"
	Model111IcmpTypePortDashUnreachable string = "port-unreachable"

	// Model111IcmpTypePrecedenceDashCutoff captures enum value "precedence-cutoff"
	Model111IcmpTypePrecedenceDashCutoff string = "precedence-cutoff"

	// Model111IcmpTypeProtocolDashUnreachable captures enum value "protocol-unreachable"
	Model111IcmpTypeProtocolDashUnreachable string = "protocol-unreachable"

	// Model111IcmpTypeRedirect captures enum value "redirect"
	Model111IcmpTypeRedirect string = "redirect"

	// Model111IcmpTypeRequiredDashOptionDashMissing captures enum value "required-option-missing"
	Model111IcmpTypeRequiredDashOptionDashMissing string = "required-option-missing"

	// Model111IcmpTypeRouterDashAdvertisement captures enum value "router-advertisement"
	Model111IcmpTypeRouterDashAdvertisement string = "router-advertisement"

	// Model111IcmpTypeRouterDashSolicitation captures enum value "router-solicitation"
	Model111IcmpTypeRouterDashSolicitation string = "router-solicitation"

	// Model111IcmpTypeSourceDashQuench captures enum value "source-quench"
	Model111IcmpTypeSourceDashQuench string = "source-quench"

	// Model111IcmpTypeSourceDashRouteDashFailed captures enum value "source-route-failed"
	Model111IcmpTypeSourceDashRouteDashFailed string = "source-route-failed"

	// Model111IcmpTypeTimeDashExceeded captures enum value "time-exceeded"
	Model111IcmpTypeTimeDashExceeded string = "time-exceeded"

	// Model111IcmpTypeTimestampDashReply captures enum value "timestamp-reply"
	Model111IcmpTypeTimestampDashReply string = "timestamp-reply"

	// Model111IcmpTypeTimestampDashRequest captures enum value "timestamp-request"
	Model111IcmpTypeTimestampDashRequest string = "timestamp-request"

	// Model111IcmpTypeTOSDashHostDashRedirect captures enum value "TOS-host-redirect"
	Model111IcmpTypeTOSDashHostDashRedirect string = "TOS-host-redirect"

	// Model111IcmpTypeTOSDashHostDashUnreachable captures enum value "TOS-host-unreachable"
	Model111IcmpTypeTOSDashHostDashUnreachable string = "TOS-host-unreachable"

	// Model111IcmpTypeTOSDashNetworkDashRedirect captures enum value "TOS-network-redirect"
	Model111IcmpTypeTOSDashNetworkDashRedirect string = "TOS-network-redirect"

	// Model111IcmpTypeTOSDashNetworkDashUnreachable captures enum value "TOS-network-unreachable"
	Model111IcmpTypeTOSDashNetworkDashUnreachable string = "TOS-network-unreachable"

	// Model111IcmpTypeTTLDashZeroDashDuringDashReassembly captures enum value "ttl-zero-during-reassembly"
	Model111IcmpTypeTTLDashZeroDashDuringDashReassembly string = "ttl-zero-during-reassembly"

	// Model111IcmpTypeTTLDashZeroDashDuringDashTransit captures enum value "ttl-zero-during-transit"
	Model111IcmpTypeTTLDashZeroDashDuringDashTransit string = "ttl-zero-during-transit"
)

// prop value enum
func (m *Model111) validateIcmpTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, model111TypeIcmpTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Model111) validateIcmpType(formats strfmt.Registry) error {
	if swag.IsZero(m.IcmpType) { // not required
		return nil
	}

	// value enum
	if err := m.validateIcmpTypeEnum("icmpType", "body", m.IcmpType); err != nil {
		return err
	}

	return nil
}

var model111TypeIcmpv6TypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["address-unreachable","bad-header","beyond-scope","communication-prohibited","destination-unreachable","echo-reply","echo-request","failed-policy","neighbor-advertisement","neighbor-solicitation","no-route","packet-too-big","parameter-problem","port-unreachable","redirect","reject-route","router-advertisement","router-solicitation","time-exceeded","ttl-zero-during-reassembly","ttl-zero-during-transit","unknown-header-type","unknown-option"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model111TypeIcmpv6TypePropEnum = append(model111TypeIcmpv6TypePropEnum, v)
	}
}

const (

	// Model111Icmpv6TypeAddressDashUnreachable captures enum value "address-unreachable"
	Model111Icmpv6TypeAddressDashUnreachable string = "address-unreachable"

	// Model111Icmpv6TypeBadDashHeader captures enum value "bad-header"
	Model111Icmpv6TypeBadDashHeader string = "bad-header"

	// Model111Icmpv6TypeBeyondDashScope captures enum value "beyond-scope"
	Model111Icmpv6TypeBeyondDashScope string = "beyond-scope"

	// Model111Icmpv6TypeCommunicationDashProhibited captures enum value "communication-prohibited"
	Model111Icmpv6TypeCommunicationDashProhibited string = "communication-prohibited"

	// Model111Icmpv6TypeDestinationDashUnreachable captures enum value "destination-unreachable"
	Model111Icmpv6TypeDestinationDashUnreachable string = "destination-unreachable"

	// Model111Icmpv6TypeEchoDashReply captures enum value "echo-reply"
	Model111Icmpv6TypeEchoDashReply string = "echo-reply"

	// Model111Icmpv6TypeEchoDashRequest captures enum value "echo-request"
	Model111Icmpv6TypeEchoDashRequest string = "echo-request"

	// Model111Icmpv6TypeFailedDashPolicy captures enum value "failed-policy"
	Model111Icmpv6TypeFailedDashPolicy string = "failed-policy"

	// Model111Icmpv6TypeNeighborDashAdvertisement captures enum value "neighbor-advertisement"
	Model111Icmpv6TypeNeighborDashAdvertisement string = "neighbor-advertisement"

	// Model111Icmpv6TypeNeighborDashSolicitation captures enum value "neighbor-solicitation"
	Model111Icmpv6TypeNeighborDashSolicitation string = "neighbor-solicitation"

	// Model111Icmpv6TypeNoDashRoute captures enum value "no-route"
	Model111Icmpv6TypeNoDashRoute string = "no-route"

	// Model111Icmpv6TypePacketDashTooDashBig captures enum value "packet-too-big"
	Model111Icmpv6TypePacketDashTooDashBig string = "packet-too-big"

	// Model111Icmpv6TypeParameterDashProblem captures enum value "parameter-problem"
	Model111Icmpv6TypeParameterDashProblem string = "parameter-problem"

	// Model111Icmpv6TypePortDashUnreachable captures enum value "port-unreachable"
	Model111Icmpv6TypePortDashUnreachable string = "port-unreachable"

	// Model111Icmpv6TypeRedirect captures enum value "redirect"
	Model111Icmpv6TypeRedirect string = "redirect"

	// Model111Icmpv6TypeRejectDashRoute captures enum value "reject-route"
	Model111Icmpv6TypeRejectDashRoute string = "reject-route"

	// Model111Icmpv6TypeRouterDashAdvertisement captures enum value "router-advertisement"
	Model111Icmpv6TypeRouterDashAdvertisement string = "router-advertisement"

	// Model111Icmpv6TypeRouterDashSolicitation captures enum value "router-solicitation"
	Model111Icmpv6TypeRouterDashSolicitation string = "router-solicitation"

	// Model111Icmpv6TypeTimeDashExceeded captures enum value "time-exceeded"
	Model111Icmpv6TypeTimeDashExceeded string = "time-exceeded"

	// Model111Icmpv6TypeTTLDashZeroDashDuringDashReassembly captures enum value "ttl-zero-during-reassembly"
	Model111Icmpv6TypeTTLDashZeroDashDuringDashReassembly string = "ttl-zero-during-reassembly"

	// Model111Icmpv6TypeTTLDashZeroDashDuringDashTransit captures enum value "ttl-zero-during-transit"
	Model111Icmpv6TypeTTLDashZeroDashDuringDashTransit string = "ttl-zero-during-transit"

	// Model111Icmpv6TypeUnknownDashHeaderDashType captures enum value "unknown-header-type"
	Model111Icmpv6TypeUnknownDashHeaderDashType string = "unknown-header-type"

	// Model111Icmpv6TypeUnknownDashOption captures enum value "unknown-option"
	Model111Icmpv6TypeUnknownDashOption string = "unknown-option"
)

// prop value enum
func (m *Model111) validateIcmpv6TypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, model111TypeIcmpv6TypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Model111) validateIcmpv6Type(formats strfmt.Registry) error {
	if swag.IsZero(m.Icmpv6Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateIcmpv6TypeEnum("icmpv6Type", "body", m.Icmpv6Type); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateID(formats strfmt.Registry) error {
	if swag.IsZero(m.ID) { // not required
		return nil
	}

	if err := validate.MinimumInt("id", "body", *m.ID, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateInInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.InInterface) { // not required
		return nil
	}

	if m.InInterface != nil {
		if err := m.InInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inInterface")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("inInterface")
			}
			return err
		}
	}

	return nil
}

var model111TypeIPVersionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["both","v4only","v6only"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model111TypeIPVersionPropEnum = append(model111TypeIPVersionPropEnum, v)
	}
}

const (

	// Model111IPVersionBoth captures enum value "both"
	Model111IPVersionBoth string = "both"

	// Model111IPVersionV4only captures enum value "v4only"
	Model111IPVersionV4only string = "v4only"

	// Model111IPVersionV6only captures enum value "v6only"
	Model111IPVersionV6only string = "v6only"
)

// prop value enum
func (m *Model111) validateIPVersionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, model111TypeIPVersionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Model111) validateIPVersion(formats strfmt.Registry) error {

	if err := validate.Required("ipVersion", "body", m.IPVersion); err != nil {
		return err
	}

	// value enum
	if err := m.validateIPVersionEnum("ipVersion", "body", *m.IPVersion); err != nil {
		return err
	}

	return nil
}

var model111TypeIpsecPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["match_inbound_ipsec","match_inbound_nonipsec"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model111TypeIpsecPolicyPropEnum = append(model111TypeIpsecPolicyPropEnum, v)
	}
}

const (

	// Model111IpsecPolicyMatchInboundIpsec captures enum value "match_inbound_ipsec"
	Model111IpsecPolicyMatchInboundIpsec string = "match_inbound_ipsec"

	// Model111IpsecPolicyMatchInboundNonipsec captures enum value "match_inbound_nonipsec"
	Model111IpsecPolicyMatchInboundNonipsec string = "match_inbound_nonipsec"
)

// prop value enum
func (m *Model111) validateIpsecPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, model111TypeIpsecPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Model111) validateIpsecPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.IpsecPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateIpsecPolicyEnum("ipsecPolicy", "body", m.IpsecPolicy); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateOutInterface(formats strfmt.Registry) error {
	if swag.IsZero(m.OutInterface) { // not required
		return nil
	}

	if m.OutInterface != nil {
		if err := m.OutInterface.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outInterface")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("outInterface")
			}
			return err
		}
	}

	return nil
}

func (m *Model111) validatePackets(formats strfmt.Registry) error {

	if err := validate.Required("packets", "body", m.Packets); err != nil {
		return err
	}

	if err := validate.MinimumInt("packets", "body", *m.Packets, 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	return nil
}

var model111TypeRejectWithPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["icmp_net_unreachable","icmp_host_unreachable","icmp_port_unreachable","icmp_proto_unreachable","icmp_net_prohibited","icmp_host_prohibited","icmp_admin_prohibited","tcp_reset,"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model111TypeRejectWithPropEnum = append(model111TypeRejectWithPropEnum, v)
	}
}

const (

	// Model111RejectWithIcmpNetUnreachable captures enum value "icmp_net_unreachable"
	Model111RejectWithIcmpNetUnreachable string = "icmp_net_unreachable"

	// Model111RejectWithIcmpHostUnreachable captures enum value "icmp_host_unreachable"
	Model111RejectWithIcmpHostUnreachable string = "icmp_host_unreachable"

	// Model111RejectWithIcmpPortUnreachable captures enum value "icmp_port_unreachable"
	Model111RejectWithIcmpPortUnreachable string = "icmp_port_unreachable"

	// Model111RejectWithIcmpProtoUnreachable captures enum value "icmp_proto_unreachable"
	Model111RejectWithIcmpProtoUnreachable string = "icmp_proto_unreachable"

	// Model111RejectWithIcmpNetProhibited captures enum value "icmp_net_prohibited"
	Model111RejectWithIcmpNetProhibited string = "icmp_net_prohibited"

	// Model111RejectWithIcmpHostProhibited captures enum value "icmp_host_prohibited"
	Model111RejectWithIcmpHostProhibited string = "icmp_host_prohibited"

	// Model111RejectWithIcmpAdminProhibited captures enum value "icmp_admin_prohibited"
	Model111RejectWithIcmpAdminProhibited string = "icmp_admin_prohibited"

	// Model111RejectWithTCPReset captures enum value "tcp_reset,"
	Model111RejectWithTCPReset string = "tcp_reset,"
)

// prop value enum
func (m *Model111) validateRejectWithEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, model111TypeRejectWithPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Model111) validateRejectWith(formats strfmt.Registry) error {
	if swag.IsZero(m.RejectWith) { // not required
		return nil
	}

	// value enum
	if err := m.validateRejectWithEnum("rejectWith", "body", m.RejectWith); err != nil {
		return err
	}

	return nil
}

func (m *Model111) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if m.Source != nil {
		if err := m.Source.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

func (m *Model111) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("target", "body", m.Target); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this model 111 based on the context it is used
func (m *Model111) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateConnectionState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOutInterface(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSource(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Model111) contextValidateConnectionState(ctx context.Context, formats strfmt.Registry) error {

	if err := m.ConnectionState.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("connectionState")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("connectionState")
		}
		return err
	}

	return nil
}

func (m *Model111) contextValidateDestination(ctx context.Context, formats strfmt.Registry) error {

	if m.Destination != nil {
		if err := m.Destination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("destination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("destination")
			}
			return err
		}
	}

	return nil
}

func (m *Model111) contextValidateInInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.InInterface != nil {
		if err := m.InInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("inInterface")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("inInterface")
			}
			return err
		}
	}

	return nil
}

func (m *Model111) contextValidateOutInterface(ctx context.Context, formats strfmt.Registry) error {

	if m.OutInterface != nil {
		if err := m.OutInterface.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outInterface")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("outInterface")
			}
			return err
		}
	}

	return nil
}

func (m *Model111) contextValidateSource(ctx context.Context, formats strfmt.Registry) error {

	if m.Source != nil {
		if err := m.Source.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("source")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Model111) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Model111) UnmarshalBinary(b []byte) error {
	var res Model111
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
