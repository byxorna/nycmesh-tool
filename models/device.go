// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Device device
//
// swagger:model device
type Device struct {

	// Device category
	// Example: wired
	// Enum: [optical wired wireless accessories]
	Category string `json:"category,omitempty"`

	// Device firmware version
	// Example: 2.0.7
	FirmwareVersion string `json:"firmwareVersion,omitempty"`

	// Id of gateway device
	// Example: f7ac9cad-ea28-4390-93c8-7add010e8ee3
	// Required: true
	ID *string `json:"id"`

	// Device IP address in CIDR format
	// Example: 192.168.1.2/24
	IPAddress string `json:"ipAddress,omitempty"`

	// Device MAC address
	// Example: 78:8a:20:f9:4e:78
	// Required: true
	// Pattern: ^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$|^([0-9a-fA-F]){12}$
	Mac *string `json:"mac"`

	// Device model
	// Example: ER-X
	Model string `json:"model,omitempty"`

	// Device name
	// Example: Main gateway
	Name string `json:"name,omitempty"`

	// Device platform id
	// Example: e50
	PlatformID string `json:"platformId,omitempty"`

	// Device status
	// Example: active
	// Required: true
	// Enum: [active connecting discovered inactive disabled disconnected unauthorized proposed unknown unplaced custom]
	Status *string `json:"status"`

	// Device type
	// Example: erouter
	Type string `json:"type,omitempty"`
}

// Validate validates this device
func (m *Device) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMac(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var deviceTypeCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["optical","wired","wireless","accessories"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		deviceTypeCategoryPropEnum = append(deviceTypeCategoryPropEnum, v)
	}
}

const (

	// DeviceCategoryOptical captures enum value "optical"
	DeviceCategoryOptical string = "optical"

	// DeviceCategoryWired captures enum value "wired"
	DeviceCategoryWired string = "wired"

	// DeviceCategoryWireless captures enum value "wireless"
	DeviceCategoryWireless string = "wireless"

	// DeviceCategoryAccessories captures enum value "accessories"
	DeviceCategoryAccessories string = "accessories"
)

// prop value enum
func (m *Device) validateCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, deviceTypeCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Device) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(m.Category) { // not required
		return nil
	}

	// value enum
	if err := m.validateCategoryEnum("category", "body", m.Category); err != nil {
		return err
	}

	return nil
}

func (m *Device) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *Device) validateMac(formats strfmt.Registry) error {

	if err := validate.Required("mac", "body", m.Mac); err != nil {
		return err
	}

	if err := validate.Pattern("mac", "body", *m.Mac, `^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$|^([0-9a-fA-F]){12}$`); err != nil {
		return err
	}

	return nil
}

var deviceTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","connecting","discovered","inactive","disabled","disconnected","unauthorized","proposed","unknown","unplaced","custom"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		deviceTypeStatusPropEnum = append(deviceTypeStatusPropEnum, v)
	}
}

const (

	// DeviceStatusActive captures enum value "active"
	DeviceStatusActive string = "active"

	// DeviceStatusConnecting captures enum value "connecting"
	DeviceStatusConnecting string = "connecting"

	// DeviceStatusDiscovered captures enum value "discovered"
	DeviceStatusDiscovered string = "discovered"

	// DeviceStatusInactive captures enum value "inactive"
	DeviceStatusInactive string = "inactive"

	// DeviceStatusDisabled captures enum value "disabled"
	DeviceStatusDisabled string = "disabled"

	// DeviceStatusDisconnected captures enum value "disconnected"
	DeviceStatusDisconnected string = "disconnected"

	// DeviceStatusUnauthorized captures enum value "unauthorized"
	DeviceStatusUnauthorized string = "unauthorized"

	// DeviceStatusProposed captures enum value "proposed"
	DeviceStatusProposed string = "proposed"

	// DeviceStatusUnknown captures enum value "unknown"
	DeviceStatusUnknown string = "unknown"

	// DeviceStatusUnplaced captures enum value "unplaced"
	DeviceStatusUnplaced string = "unplaced"

	// DeviceStatusCustom captures enum value "custom"
	DeviceStatusCustom string = "custom"
)

// prop value enum
func (m *Device) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, deviceTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Device) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this device based on context it is used
func (m *Device) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *Device) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Device) UnmarshalBinary(b []byte) error {
	var res Device
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
