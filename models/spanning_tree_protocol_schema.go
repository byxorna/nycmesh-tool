// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SpanningTreeProtocolSchema spanning tree protocol schema
//
// swagger:model SpanningTreeProtocolSchema
type SpanningTreeProtocolSchema struct {

	// Set to true if STP is enabled.
	// Example: true
	// Required: true
	Enabled *bool `json:"enabled"`

	// Time spent in listening and learning state (in seconds) prior to entering forwarding state.
	// Example: 30
	// Required: true
	// Maximum: 30
	// Minimum: 4
	ForwardDelay *int64 `json:"forwardDelay"`

	// Time between each bridge protocol data unit (BPDU) that is sent on a port (in seconds).
	//       Updating hello time is disallowed per IEEE 802.1Q-REV 200.
	//
	// Example: 2
	// Required: true
	// Maximum: 100
	// Minimum: 0
	HelloTime *int64 `json:"helloTime"`

	// Length of time (in seconds) since last BPDU received on this port before aging out the BPDU and
	//       initiating topology reconvergence.
	// Example: 30
	// Required: true
	// Maximum: 40
	// Minimum: 6
	MaxAge *int64 `json:"maxAge"`

	// STP root bridge priority.
	// Example: 32000
	// Required: true
	// Maximum: 61440
	// Minimum: 0
	Priority *int64 `json:"priority"`

	// Version of STP: RSTP (802.1w), MSTP (802.1s) or STP (802.1d).
	// Example: RSTP
	// Required: true
	// Enum: [RSTP MSTP STP]
	Version *string `json:"version"`
}

// Validate validates this spanning tree protocol schema
func (m *SpanningTreeProtocolSchema) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateForwardDelay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHelloTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxAge(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePriority(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SpanningTreeProtocolSchema) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *SpanningTreeProtocolSchema) validateForwardDelay(formats strfmt.Registry) error {

	if err := validate.Required("forwardDelay", "body", m.ForwardDelay); err != nil {
		return err
	}

	if err := validate.MinimumInt("forwardDelay", "body", *m.ForwardDelay, 4, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("forwardDelay", "body", *m.ForwardDelay, 30, false); err != nil {
		return err
	}

	return nil
}

func (m *SpanningTreeProtocolSchema) validateHelloTime(formats strfmt.Registry) error {

	if err := validate.Required("helloTime", "body", m.HelloTime); err != nil {
		return err
	}

	if err := validate.MinimumInt("helloTime", "body", *m.HelloTime, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("helloTime", "body", *m.HelloTime, 100, false); err != nil {
		return err
	}

	return nil
}

func (m *SpanningTreeProtocolSchema) validateMaxAge(formats strfmt.Registry) error {

	if err := validate.Required("maxAge", "body", m.MaxAge); err != nil {
		return err
	}

	if err := validate.MinimumInt("maxAge", "body", *m.MaxAge, 6, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("maxAge", "body", *m.MaxAge, 40, false); err != nil {
		return err
	}

	return nil
}

func (m *SpanningTreeProtocolSchema) validatePriority(formats strfmt.Registry) error {

	if err := validate.Required("priority", "body", m.Priority); err != nil {
		return err
	}

	if err := validate.MinimumInt("priority", "body", *m.Priority, 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("priority", "body", *m.Priority, 61440, false); err != nil {
		return err
	}

	return nil
}

var spanningTreeProtocolSchemaTypeVersionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RSTP","MSTP","STP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		spanningTreeProtocolSchemaTypeVersionPropEnum = append(spanningTreeProtocolSchemaTypeVersionPropEnum, v)
	}
}

const (

	// SpanningTreeProtocolSchemaVersionRSTP captures enum value "RSTP"
	SpanningTreeProtocolSchemaVersionRSTP string = "RSTP"

	// SpanningTreeProtocolSchemaVersionMSTP captures enum value "MSTP"
	SpanningTreeProtocolSchemaVersionMSTP string = "MSTP"

	// SpanningTreeProtocolSchemaVersionSTP captures enum value "STP"
	SpanningTreeProtocolSchemaVersionSTP string = "STP"
)

// prop value enum
func (m *SpanningTreeProtocolSchema) validateVersionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, spanningTreeProtocolSchemaTypeVersionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SpanningTreeProtocolSchema) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	// value enum
	if err := m.validateVersionEnum("version", "body", *m.Version); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this spanning tree protocol schema based on context it is used
func (m *SpanningTreeProtocolSchema) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *SpanningTreeProtocolSchema) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SpanningTreeProtocolSchema) UnmarshalBinary(b []byte) error {
	var res SpanningTreeProtocolSchema
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
