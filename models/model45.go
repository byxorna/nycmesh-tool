// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Model45 model 45
//
// swagger:model Model 45
type Model45 struct {

	// Custom description text
	// Example: Some comment
	// Required: true
	// Max Length: 25
	Comment *string `json:"comment"`

	// Set to true if rule is enabled
	// Example: true
	// Required: true
	Enabled *bool `json:"enabled"`

	// IPv4 address of the target LAN device
	// Example: 192.168.4.4
	// Required: true
	LanAddress *string `json:"lanAddress"`

	// lan port
	// Required: true
	LanPort LanPort `json:"lanPort"`

	// Forwarded protocols
	// Example: tcpudp
	// Required: true
	// Enum: [tcpudp tcp udp]
	Protocol *string `json:"protocol"`

	// wan port
	// Required: true
	WanPort WanPort `json:"wanPort"`
}

// Validate validates this model 45
func (m *Model45) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanPort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWanPort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Model45) validateComment(formats strfmt.Registry) error {

	if err := validate.Required("comment", "body", m.Comment); err != nil {
		return err
	}

	if err := validate.MaxLength("comment", "body", *m.Comment, 25); err != nil {
		return err
	}

	return nil
}

func (m *Model45) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

func (m *Model45) validateLanAddress(formats strfmt.Registry) error {

	if err := validate.Required("lanAddress", "body", m.LanAddress); err != nil {
		return err
	}

	return nil
}

func (m *Model45) validateLanPort(formats strfmt.Registry) error {

	if err := validate.Required("lanPort", "body", m.LanPort); err != nil {
		return err
	}

	if err := m.LanPort.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("lanPort")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("lanPort")
		}
		return err
	}

	return nil
}

var model45TypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["tcpudp","tcp","udp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		model45TypeProtocolPropEnum = append(model45TypeProtocolPropEnum, v)
	}
}

const (

	// Model45ProtocolTcpudp captures enum value "tcpudp"
	Model45ProtocolTcpudp string = "tcpudp"

	// Model45ProtocolTCP captures enum value "tcp"
	Model45ProtocolTCP string = "tcp"

	// Model45ProtocolUDP captures enum value "udp"
	Model45ProtocolUDP string = "udp"
)

// prop value enum
func (m *Model45) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, model45TypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Model45) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *Model45) validateWanPort(formats strfmt.Registry) error {

	if err := validate.Required("wanPort", "body", m.WanPort); err != nil {
		return err
	}

	if err := m.WanPort.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("wanPort")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("wanPort")
		}
		return err
	}

	return nil
}

// ContextValidate validate this model 45 based on the context it is used
func (m *Model45) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLanPort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWanPort(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Model45) contextValidateLanPort(ctx context.Context, formats strfmt.Registry) error {

	if err := m.LanPort.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("lanPort")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("lanPort")
		}
		return err
	}

	return nil
}

func (m *Model45) contextValidateWanPort(ctx context.Context, formats strfmt.Registry) error {

	if err := m.WanPort.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("wanPort")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("wanPort")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Model45) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Model45) UnmarshalBinary(b []byte) error {
	var res Model45
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
